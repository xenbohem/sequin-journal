<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Canvas Sequins Ultra Fast</title>
<style>
  body {
    background: #0b0214;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
  }
  canvas {
    border-radius: 12px;
    background: radial-gradient(circle at top left, #3e2169, #160b29);
    box-shadow: 0 0 20px rgba(120,60,255,0.5);
  }
</style>
</head>
<body>

<canvas id="sequins" width="450" height="300"></canvas>

<script>
const canvas = document.getElementById("sequins");
const ctx = canvas.getContext("2d");

const cols = 18;
const rows = 12;
const size = 20;   // sequin size (quarter bigger is handled here)
const gap = 6;

let sequins = [];

for (let y = 0; y < rows; y++) {
  for (let x = 0; x < cols; x++) {
    sequins.push({
      x: x * (size + gap) + 30,
      y: y * (size + gap) + 30,
      flipped: false,
      flipProgress: 0
    });
  }
}

function drawSequin(s) {
  const progress = s.flipProgress;
  const flipAngle = progress * Math.PI;

  ctx.save();
  ctx.translate(s.x + size/2, s.y + size/2);
  ctx.scale(Math.cos(flipAngle), 1);
  ctx.translate(-size/2, -size/2);

  let colorFront = "#aa66ff";   // purple
  let colorBack = "#3a3dff";    // indigo

  const color = progress < 0.5 ? colorFront : colorBack;

  const gradient = ctx.createRadialGradient(
    size/2, size/2, 2,
    size/2, size/2, size
  );
  gradient.addColorStop(0, color);
  gradient.addColorStop(1, "#000");

  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.arc(size/2, size/2, size/2, 0, Math.PI*2);
  ctx.fill();

  ctx.restore();
}

function animate() {
  ctx.clearRect(0,0,canvas.width, canvas.height);

  for (let s of sequins) {
    if (s.target !== undefined) {
      s.flipProgress += (s.target - s.flipProgress) * 0.15;
    }
    drawSequin(s);
  }
  requestAnimationFrame(animate);
}
animate();

canvas.addEventListener("mousemove", e => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  sequins.forEach(s => {
    const dx = mx - (s.x + size/2);
    const dy = my - (s.y + size/2);
    if (Math.sqrt(dx*dx + dy*dy) < size*1.4) {
      s.target = 1; // flip fully
    }
  });
});

canvas.addEventListener("click", e => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  sequins.forEach(s => {
    const dx = mx - (s.x + size/2);
    const dy = my - (s.y + size/2);
    if (Math.sqrt(dx*dx + dy*dy) < size*1.3) {
      s.target = 1; // stay flipped
    }
  });
});

canvas.addEventListener("dblclick", e => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  sequins.forEach(s => {
    const dx = mx - (s.x + size/2);
    const dy = my - (s.y + size/2);
    if (Math.sqrt(dx*dx + dy*dy) < size*1.3) {
      s.target = 0; // flip back
    }
  });
});
</script>

</body>
</html>
